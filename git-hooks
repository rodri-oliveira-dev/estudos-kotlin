import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.springframework.http.HttpStatus
import java.util.UUID

class ResgateServiceTest {
    private lateinit var externalResource: ExternalResource
    private lateinit var resgateProvider: ResgateProvider
    private lateinit var obterAutorizacaoRequestMapper: ObterAutorizacaoRequestMapper
    private lateinit var obterAutorizacaoResponseMapper: ObterAutorizacaoResponseMapper
    private lateinit var confirmacaoResgateRequestMapper: ConfirmacaoResgateRequestMapper
    private lateinit var confirmacaoResgateResponseMapper: ConfirmacaoResgateResponseMapper
    private lateinit var awsSecrets: AwsSecrets
    private lateinit var resgateConfiguration: ResgateConfiguration
    private lateinit var resgateService: ResgateService

    @BeforeEach
    fun setUp() {
        externalResource = mockk(relaxed = true)
        resgateProvider = mockk()
        obterAutorizacaoRequestMapper = mockk()
        obterAutorizacaoResponseMapper = mockk()
        confirmacaoResgateRequestMapper = mockk()
        confirmacaoResgateResponseMapper = mockk()
        awsSecrets = mockk()
        resgateConfiguration = mockk()

        resgateService = ResgateService(
            externalResource,
            resgateProvider,
            obterAutorizacaoRequestMapper,
            obterAutorizacaoResponseMapper,
            confirmacaoResgateRequestMapper,
            confirmacaoResgateResponseMapper,
            awsSecrets,
            resgateConfiguration
        )
    }

    @Test
    fun `deve autorizar com sucesso`() {
        // Arrange
        val participante = Participante(/* preencha com os dados necessários */)
        val observabilidade = Observabilidade(UUID.randomUUID().toString(), UUID.randomUUID().toString())
        val autorizacaoRequest = ObterAutorizacaoRequest(/* preencha com os dados necessários */)
        val autorizacaoResponse = ObterAutorizacaoResponse(/* preencha com os dados necessários */)
        val resgate = Resgate(/* preencha com os dados necessários */)

        every { awsSecrets.get().client_id } returns "clientId"
        every { obterAutorizacaoRequestMapper.from(participante) } returns autorizacaoRequest
        every { resgateProvider.obterAutorizacao(any(), any(), any(), any(), any(), any()) } returns autorizacaoResponse
        every { obterAutorizacaoResponseMapper.from(autorizacaoResponse, participante) } returns resgate

        // Act
        val result = resgateService.autorizar(participante, observabilidade)

        // Assert
        assertEquals(resgate, result)
        verify { resgateProvider.obterAutorizacao(any(), any(), any(), any(), any(), any()) }
    }

    @Test
    fun `deve lançar BusinessException quando participante não encontrado`() {
        // Arrange
        val participante = Participante(/* preencha com os dados necessários */)
        val observabilidade = Observabilidade(UUID.randomUUID().toString(), UUID.randomUUID().toString())
        val autorizacaoRequest = ObterAutorizacaoRequest(/* preencha com os dados necessários */)
        val responseException = HttpClientResponseException(
            "Participante não encontrado.",
            HttpResponse.badRequest<Any>().status(HttpStatus.UNPROCESSABLE_ENTITY))
            
     every { awsSecrets.get().client_id } returns "clientId"
    every { obterAutorizacaoRequestMapper.from(participante) } returns autorizacaoRequest
    every { resgateProvider.obterAutorizacao(any(), any(), any(), any(), any(), any()) } throws responseException

    // Act & Assert
    val exception = assertThrows<BusinessException> {
        resgateService.autorizar(participante, observabilidade)
    }

    assertEquals(PARTICIPANTE_NAO_ENCONTRADO, exception.code)
    verify { resgateProvider.obterAutorizacao(any(), any(), any(), any(), any(), any()) }
}

@Test
fun `deve lançar BusinessException quando autorizacao nao processada`() {
    // Arrange
    val participante = Participante(/* preencha com os dados necessários */)
    val observabilidade = Observabilidade(UUID.randomUUID().toString(), UUID.randomUUID().toString())
    val autorizacaoRequest = ObterAutorizacaoRequest(/* preencha com os dados necessários */)
    val responseException = HttpClientResponseException(
        "Falha ao autorizar.",
        HttpResponse.badRequest<Any>().status(HttpStatus.UNPROCESSABLE_ENTITY)
    )

    every { awsSecrets.get().client_id } returns "clientId"
    every { obterAutorizacaoRequestMapper.from(participante) } returns autorizacaoRequest
    every { resgateProvider.obterAutorizacao(any(), any(), any(), any(), any(), any()) } throws responseException

    // Act & Assert
    val exception = assertThrows<BusinessException> {
        resgateService.autorizar(participante, observabilidade)
    }

    assertEquals(AUTORIZACAO_NAO_PROCESSADA, exception.code)
    verify { resgateProvider.obterAutorizacao(any(), any(), any(), any(), any(), any()) }
}

@Test
fun `deve lançar BusinessException quando pedido duplicado`() {
    // Arrange
    val participante = Participante(/* preencha com os dados necessários */)
    val observabilidade = Observabilidade(UUID.randomUUID().toString(), UUID.randomUUID().toString())
    val autorizacaoRequest = ObterAutorizacaoRequest(/* preencha com os dados necessários */)
    val responseException = HttpClientResponseException(
        "Pedido Duplicado.",
        HttpResponse.badRequest<Any>().status(HttpStatus.CONFLICT)
    )

    every { awsSecrets.get().client_id } returns "clientId"
    every { obterAutorizacaoRequestMapper.from(participante) } returns autorizacaoRequest
    every { resgateProvider.obterAutorizacao(any(), any(), any(), any(), any(), any()) } throws responseException

    // Act & Assert
    val exception = assertThrows<BusinessException> {
        resgateService.autorizar(participante, observabilidade)
    }

    assertEquals(PEDIDO_DUPLICADO, exception.code)
    verify { resgateProvider.obterAutorizacao(any(), any(), any(), any(), any(), any()) }
}
            
